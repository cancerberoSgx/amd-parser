var esprima = require('esprima')
var assert = require('assert')

// if no name is given in the define() declaration we will use given defaultModuleName and if none we will generate a random one.
function parse(str, defaultModuleName){
	var esprimaConfig = {
		raw: true,
		range: true,	
		comment: true		
	}
	var ast = esprima.parse(str, esprimaConfig)
	var defineExpr = findDefineExpression(ast)
	// console.log(JSON.stringify(defineExpr,0,2))
	var defineHasName = defineExpr.expression.arguments[0].type=='Literal'

	var name
	if(defineHasName){
		name = defineExpr.expression.arguments[0].value
	}
	else if(defaultModuleName)
	{
		name = defaultModuleName
	}
	else
	{
		'autogenerated_'+new Date().getTime()
	}

	var dependencies = [], 
		depsArg = defineHasName ? defineExpr.expression.arguments[1] : defineExpr.expression.arguments[0]
	assert.equal(depsArg.type=='ArrayExpression', true, 'require dependencies node is ArrayExpression')

	dependencies = depsArg.elements.map((e)=>e.value)

	var callbackExpr
	if(defineHasName){
		callbackExpr = defineExpr.expression.arguments[2]
	}
	else{
		callbackExpr = defineExpr.expression.arguments[1]
	}

	// console.log(callbackExpr)
	var callbackArguments = callbackExpr.params.map((p)=>p.name) // TODO

	var bodyNode = callbackExpr.body
	var body = str.substring(bodyNode.range[0], bodyNode.range[1])
	

	var parsed = {name, dependencies, callbackArguments, body}
	return parsed
}

function findDefineExpression(ast){
	//return first define() function call expression (root level)
	return ast.body.find((s) => s.type=='ExpressionStatement' && 
		s.expression.type=='CallExpression' && 
		s.expression.callee.name=='define'
	)
}
module.exports = {parse}

